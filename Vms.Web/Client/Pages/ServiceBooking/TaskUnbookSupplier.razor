@inject ServerApiHttpClient Api

<section class="task-form">
    <h1>Unbook Supplier</h1>
    @if (isLoaded)
    {
        <EditForm EditContext="editContext" OnValidSubmit="ValidSubmit">
            <DataAnnotationsValidator />
            <ValidationSummary />
            
            <InputRadioGroup @bind-Value="model.Result">

                <div class="option">
                    <div class="option-select">
                        <InputRadio id="unbooked" Value="TaskUnbookSupplierDto.TaskResult.Unbooked" />
                        <label for="unbooked">Unbooked</label>
                    </div>
                    <fieldset class="option-data" disabled="@OptionUnbookedDisabled">
                        <label for="reason">Date</label>
                        <InputTextArea id="reason" @bind-Value="model.Reason" />
                        <ValidationMessage For="@(() => model.Reason)" />
                    </fieldset>
                </div>
            </InputRadioGroup>

            <div class="buttons">
                @if (errorMessage is not null)
                {
                    <div class="error">
                        @errorMessage
                    </div>
                }
                <button type="button" @onclick="() => OnCompleted.InvokeAsync(false)">Cancel</button>
                <button type="submit">Ok</button>
            </div>
        </EditForm>
    }
</section>
@code {
    [Parameter, EditorRequired] public ServiceBookingFullDto ServiceBooking { get; set; } = null!;
    //[Parameter, EditorRequired] public EventCallback OnClose { get; set; }
    [Parameter, EditorRequired] public EventCallback<bool> OnCompleted { get; set; }

    TaskUnbookSupplierDto model = new();

    bool isLoaded;
    EditContext editContext = null!;
    ValidationMessageStore messageStore = null!;
    bool OptionUnbookedDisabled => model.Result != TaskUnbookSupplierDto.TaskResult.Unbooked;
    string? errorMessage;

    async Task ValidSubmit()
    {
        errorMessage = null;

        var result = await Api.UnbookSupplier(ServiceBooking.Id, model);
        if (result is PostResponse.Success)
        {
            await OnCompleted.InvokeAsync(true);
        }
        else
        {
            messageStore.Clear();

            if (result is PostResponse.UnprocessableEntity ue)
            {
                foreach (var error in ue.ValidationErrors)
                {
                    messageStore.Add(editContext.Field(error.Key), error.Value);
                }
            }
            else
            {
                if (result is PostResponse.BadRequest br)
                {
                    messageStore.Add(editContext.Field(""), br.ErrorMessage);
                }
                else// if (result is PostResponse.Failure)
                {
                    messageStore.Add(editContext.Field(""), "There was a problem sending your request.");
                }
            }
            
            editContext.NotifyValidationStateChanged();
        }
    }

    protected override void OnInitialized()
    {
        ArgumentNullException.ThrowIfNull(ServiceBooking);
        if (!OnCompleted.HasDelegate) throw new ArgumentNullException(nameof(OnCompleted));

        editContext = new(model);
        messageStore = new(editContext);
        isLoaded = true;
    }
}
