@inject ILogger<MenuButton> Logger
@inject IJSRuntime JS

@{
    var className1 = domNodeFocused ? "focus" : string.Empty;
}
<div  class="menu-button-actions @className1" id="wdq87dqx"
@onfocusin="onFocusin"
@onfocusout="onFocusout">
    <button type="button" id="menubutton1" aria-haspopup="true" aria-controls="menu1" aria-expanded="@isOpen.ToHtml()"
    @ref="buttonNode"
    
    @onclick="onButtonClick" @onclick:preventDefault @onclick:stopPropagation>
        Actions
        <svg xmlns="http://www.w3.org/2000/svg" class="down" width="12" height="9" viewBox="0 0 12 9">
            <polygon points="1 0, 11 0, 6 8"></polygon>
        </svg>
    </button>
    @{
        var activeDescendant = $"mi{selectedMenuItem}";
    }
    <ul id="menu1" role="menu" tabindex="-1" aria-labelledby="menubutton1" aria-activedescendant="@activeDescendant" style="@menuNodeStyle()" @ref="menuNode">

        @foreach (var mi in MenuItems)
        {
            var menuItem = mi.Value;

            var id = $"mi{menuItem.Index}";

            var className2 = selectedMenuItem == menuItem.Index ? "focus" : string.Empty;

            <li id="@id" role="menuitem" @ref="menuItem.Ref" class="@className2" tabindex="-1"
            @onclick="async (e) => await onMenuitemClick(e, menuItem.Index)"
            @onmouseover="(e) => onMenuitemMouseover(e, menuItem.Index)">@menuItem.Name</li>
        }

    </ul>
</div>

@code {
    [EditorRequired, Parameter]
    public string[] Items { get; set; } = null!;

    private Dictionary<int, MenuItem> MenuItems { get; set; } = new();
    private int selectedMenuItem;

    private ElementReference menuNode;
    private ElementReference buttonNode;
    private DotNetObjectReference<MenuButton>? objRef;

    private bool domNodeFocused = false;

    private record MenuItem
    {
        public int Index { get; set; }
        public string Name { get; set; } = string.Empty;
        public ElementReference Ref { get; set; }
    }

    protected override void OnInitialized()
    {
        objRef = DotNetObjectReference.Create(this);
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        MenuItems.Clear();
        for (int index = 0; index < Items.Length; index++)
        {
            MenuItems.Add(index, new MenuItem() { Index = index, Name = Items[index] });
        }
        Logger.LogInformation("Menu Items: {menuitems}.", MenuItems);
    }

    [JSInvokable]
    public async Task OpenFirst()
    {
        Logger.LogInformation("OpenFirst()");
        await openPopup();
        setFocusToFirstMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public async Task Close()
    {
        Logger.LogInformation("Close()");
        await closePopup();
        StateHasChanged();
    }
    [JSInvokable]
    public async Task CloseAndPerformMenuAction()
    {
        Logger.LogInformation("CloseAndPerformMenuAction()");
        await closePopup();

        StateHasChanged();
    }
    [JSInvokable]
    public async Task OpenLast()
    {
        Logger.LogInformation("OpenLast()");
        await openPopup();
        setFocusToLastMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public void Previous()
    {
        setFocusToPreviousMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public void Next()
    {
        setFocusToNextMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public void First()
    {
        setFocusToFirstMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public void Last()
    {
        setFocusToLastMenuitem();
        StateHasChanged();
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var result = await JS.InvokeAsync<bool>("myApp.installKeydown", "wdq87dqx", objRef);
        }

        if (mustSetMenuNodeFocus) {
            mustSetMenuNodeFocus = false;
            await menuNode.FocusAsync();
        }
    }

    private bool isOpen = false;
    private string menuNodeStyle() => isOpen ? "display: block" : "display: none";
    //private string menuNodeStyle() => isOpen ? "visibility: visible" : "visibility: hidden";
    private bool mustSetMenuNodeFocus = false;
    private async Task openPopup()
    {
        isOpen = true;
        //await Task.Yield();
        mustSetMenuNodeFocus = true;
        //await menuNode.FocusAsync();
        setFocusToFirstMenuitem();
    }

    private async Task closePopup()
    {
        isOpen = false;
        await buttonNode.FocusAsync();
    }

    private void setFocusToFirstMenuitem()
    {
        selectedMenuItem = 0;
    }

    private void setFocusToLastMenuitem()
    {
        selectedMenuItem = MenuItems.Count - 1;
    }

    private void setFocusToPreviousMenuitem()
    {
        selectedMenuItem = selectedMenuItem == 0
            ? MenuItems.Count - 1
            : 0;
    }

    private void setFocusToNextMenuitem()
    {
        selectedMenuItem = selectedMenuItem == MenuItems.Count - 1
            ? 0
            : selectedMenuItem + 1;
    }

    [JSInvokable]
    private void setFocusByFirstCharacter(string key)
    {
        Logger.LogInformation("setFocusByFirstCharacter() key: {key}", key);
        //TODO
        StateHasChanged();
    }

    private async Task onButtonClick(MouseEventArgs e)
    {
        if (isOpen)
        {
            await closePopup();
        }
        else
        {
            await openPopup();
        }
    }

    private async Task onMenuitemClick(MouseEventArgs e, int index)
    {
        await closePopup();
        Logger.LogInformation("Selected index {index}.", index);
    }

    private void onMenuitemMouseover(MouseEventArgs e, int index)
    {
        selectedMenuItem = index;
    }

    private void onFocusin()
    {
        domNodeFocused = true;
    }

    private void onFocusout()
    {
        domNodeFocused = false;
    }

    // TODO???
    private void onBackgroundMousedown()
    {

    }
}
