@inject ILogger<MenuButton> Logger
@inject IJSRuntime JS

@{
    var className1 = domNodeFocused ? "focus" : string.Empty;
}
<div  class="menu-button-actions @className1" id="@Id"
@onfocusin="onFocusin"
@onfocusout="onFocusout">
    <button type="button" aria-haspopup="true" aria-controls="menu1" aria-expanded="@isOpen.ToHtml()"
    @ref="buttonNode"
    
    @onclick="onButtonClick" @onclick:preventDefault @onclick:stopPropagation>
        Actions
        <svg xmlns="http://www.w3.org/2000/svg" class="down" width="12" height="9" viewBox="0 0 12 9">
            <polygon points="1 0, 11 0, 6 8"></polygon>
        </svg>
    </button>
    @{
        var activeDescendant = $"mi{selectedMenuItem}";
    }
    <ul role="menu" tabindex="-1" aria-labelledby="menubutton1" aria-activedescendant="@activeDescendant" 
        style="@menuNodeStyle()" @ref="menuNode">

        @foreach (var mi in MenuItems)
        {
            var menuItem = mi.Value;

            var id = $"mi{menuItem.Index}";

            var className2 = selectedMenuItem == menuItem.Index ? "focus" : string.Empty;

            <li id="@id" role="menuitem" @ref="menuItem.Ref" class="@className2" tabindex="-1"
            @onclick="async (e) => await onMenuitemClick(e, menuItem.Index)"
            @onmouseover="(e) => onMenuitemMouseover(e, menuItem.Index)">@menuItem.Name</li>
        }

    </ul>
</div>

@code {
    [EditorRequired, Parameter]
    public string[] Items { get; set; } = null!;

    [Parameter]
    public EventCallback<string> OnSelectCallback { get; set; }

    private string Id = GenerateRandomString(10);
    private int bgHook = 0;

    private Dictionary<int, MenuItem> MenuItems { get; set; } = new();
    private int selectedMenuItem;

    private ElementReference menuNode;
    private ElementReference buttonNode;
    private DotNetObjectReference<MenuButton>? objRef;

    private bool domNodeFocused = false;

    private record MenuItem
    {
        public int Index { get; set; }
        public string Name { get; set; } = string.Empty;
        public ElementReference Ref { get; set; }
        public char FirstChar { get; set; }
    }

    protected override void OnInitialized()
    {
        objRef = DotNetObjectReference.Create(this);
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        MenuItems.Clear();
        for (int index = 0; index < Items.Length; index++)
        {
            if (string.IsNullOrEmpty(Items[index])) 
                throw new InvalidOperationException("Data cannot be an empty string.");

            MenuItems.Add(index, new MenuItem() { 
                Index = index, 
                Name = Items[index], 
                FirstChar = Items[index].Substring(0,1).ToLower()[0] });
        }
        Logger.LogInformation("Menu Items: {menuitems}.", MenuItems);
    }

    [JSInvokable]
    public async Task OpenFirst()
    {
        Logger.LogInformation("OpenFirst()");
        await openPopup();
        setFocusToFirstMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public async Task Close()
    {
        Logger.LogInformation("Close()");
        await closePopup();
        StateHasChanged();
    }
    [JSInvokable]
    public async Task CloseAndPerformMenuAction()
    {
        Logger.LogInformation("CloseAndPerformMenuAction()");
        await closePopup();
        await OnSelectCallback.InvokeAsync(MenuItems[selectedMenuItem].Name);
        StateHasChanged();
    }
    [JSInvokable]
    public async Task OpenLast()
    {
        Logger.LogInformation("OpenLast()");
        await openPopup();
        setFocusToLastMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public void Previous()
    {
        setFocusToPreviousMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public void Next()
    {
        setFocusToNextMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public void First()
    {
        setFocusToFirstMenuitem();
        StateHasChanged();
    }
    [JSInvokable]
    public void Last()
    {
        setFocusToLastMenuitem();
        StateHasChanged();
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var result = await JS.InvokeAsync<bool>("menuButton.installKeydown", Id, objRef);
        }

        if (mustSetMenuNodeFocus) {
            mustSetMenuNodeFocus = false;
            await menuNode.FocusAsync();
        }
    }

    private bool isOpen = false;
    private string menuNodeStyle() => isOpen ? "display: block" : "display: none";

    private bool mustSetMenuNodeFocus = false;
    private async Task openPopup()
    {
        isOpen = true;
        //await Task.Yield();
        mustSetMenuNodeFocus = true;
        //await menuNode.FocusAsync();
        setFocusToFirstMenuitem();
        bgHook = await JS.InvokeAsync<int>("menuButton.installBackgroundHook", Id, objRef);
        Logger.LogInformation("installBackgroundHook returned {result}.", bgHook);
    }

    private async Task closePopup()
    {
        isOpen = false;
        await buttonNode.FocusAsync();
        var result = await JS.InvokeAsync<bool>("menuButton.removeBackgroundHook", bgHook);
        Logger.LogInformation("removeBackgroundHook returned {result}.", result);
    }

    private void setFocusToFirstMenuitem()
    {
        selectedMenuItem = 0;
    }

    private void setFocusToLastMenuitem()
    {
        selectedMenuItem = MenuItems.Count - 1;
    }

    private void setFocusToPreviousMenuitem()
    {
        selectedMenuItem = selectedMenuItem == 0
            ? MenuItems.Count - 1
            : 0;
    }

    private void setFocusToNextMenuitem()
    {
        selectedMenuItem = selectedMenuItem == MenuItems.Count - 1
            ? 0
            : selectedMenuItem + 1;
    }

    [JSInvokable]
    public void setFocusByFirstCharacter(string key)
    {
        Logger.LogInformation("setFocusByFirstCharacter() key: {key}", key);

        if (key.Length == 0)
        {
            return;
        }

        var keyChar = key[0];

        var start = selectedMenuItem + 1;
        if (start > MenuItems.Count - 1)
        {
            start = 0;
        }
        
        int FindNextMenuItemByFirstChar(int s, int e)
        {
            for (var i = s; i < e; i++)
            {
                if (MenuItems[i].FirstChar == keyChar)
                {
                    return i;
                }
            }
            return -1;
        }


        var index = FindNextMenuItemByFirstChar(start, MenuItems.Count);
        if (index == -1)
        {
            index = FindNextMenuItemByFirstChar(0, start - 1);
        }

        if (index > -1)
            selectedMenuItem = index;

        //TODO
        StateHasChanged();
    }

    private async Task onButtonClick(MouseEventArgs e)
    {
        if (isOpen)
        {
            await closePopup();
        }
        else
        {
            await openPopup();
        }
    }

    private async Task onMenuitemClick(MouseEventArgs e, int index)
    {
        await closePopup();
        Logger.LogInformation("Selected index {index}.", index);
        await OnSelectCallback.InvokeAsync(MenuItems[selectedMenuItem].Name);
    }

    private void onMenuitemMouseover(MouseEventArgs e, int index)
    {
        selectedMenuItem = index;
    }

    private void onFocusin()
    {
        domNodeFocused = true;
    }

    private void onFocusout()
    {
        domNodeFocused = false;
    }

    // TODO???
    private void onBackgroundMousedown()
    {

    }

    private static Random random = new Random(); // create a random object
    public static string GenerateRandomString(int length)
    {
        const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; // define the valid characters
        return new string(Enumerable.Repeat(chars, length) // repeat the chars string length times
            .Select(s => s[random.Next(s.Length)]) // select a random character from each repetition
            .ToArray()); // convert to an array and then to a string
    }
}
