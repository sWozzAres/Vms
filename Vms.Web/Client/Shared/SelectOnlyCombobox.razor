@inject IJSRuntime JS
@inject ILogger<SelectOnlyCombobox> Logger

@implements IDisposable

<label id="@id" class="@labelClassName">@Label</label>
<div @ref="comboEl" class="@comboClassName">

    <div id="@comboInputId" @ref="comboInputEl" class="combo-input" role="combobox" tabindex="0"
         aria-controls="listbox1" aria-expanded="@open.ToHtml()" aria-haspopup="listbox" aria-labelledby="@id" aria-activedescendant="@activeItemId"
        @onblur="onComboInputBlur" @onclick="onComboInputClick">
        @selectItems[selectedIndex].Name
    </div>
    
    <div id="@comboMenuId" @ref="comboMenuEl" class="combo-menu" role="listbox" aria-labelledby="@id" tabindex="-1">

        @for (int index = 0; index < selectItems.Count; index++)
        {
            var idx = index;
            var item = selectItems[idx];

            var isSelected = selectedIndex == idx;
            var className2 = activeIndex == idx ? "combo-option option-current" : "combo-option";

            <div id="@item.Id" role="option" class="@className2" aria-selected="@isSelected.ToHtml()"
            @onclick="async () => await onComboMenuClick(idx)" @onclick:stopPropagation
            @onmousedown="() => onComboMenuMouseDown()">
                @item.Name
            </div>
        }
    </div>
</div>


@code {
    [EditorRequired, Parameter]
    public string[] Items { get; set; } = null!;

    [EditorRequired, Parameter]
    public string Label { get; set; } = null!;

    [Parameter]
    public bool LabelHidden { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object> InputAttributes { get; set; } = null!;

    Dictionary<int, SelectItem> selectItems { get; set; } = new();

    string labelClassName => LabelHidden ? "combo-label hidden" : "combo-label";
    string comboClassName => open ? "combo open" : "combo";
    string activeItemId => open ? itemId(activeIndex) : string.Empty;
    string itemId(int i) => $"{id}-{i}";

    // ids
    string id = null!;
    string comboInputId = null!;
    string comboMenuId = null!;

    // element references
    ElementReference comboEl;
    ElementReference comboInputEl;
    ElementReference comboMenuEl;

    DotNetObjectReference<SelectOnlyCombobox>? objRef;
    int bgHook = 0;

    // state
    int activeIndex = 0;
    int selectedIndex = 0;
    bool open;
    string searchString = string.Empty;

    bool ignoreBlur;

    Timer? timer;

    async Task updateMenuState(bool shouldOpen, bool callFocus = true)
    {
        if (shouldOpen == open)
            return;

        open = shouldOpen;

        if (callFocus)
            await comboInputEl.FocusAsync();
    }
    
    void selectOption(int index) => selectedIndex = index;

    #region ComboInput events
    async Task onComboInputBlur()
    {
        if (ignoreBlur)
        {
            ignoreBlur = false;
            return;
        }

        if (open)
        {
            selectOption(activeIndex);
            await updateMenuState(false, false);
        }
    }

    async Task onComboInputClick() => await updateMenuState(!open, false);
    #endregion
    
    void onOptionChange(int index) => activeIndex = index;

    #region ComboMenu events
    async Task onComboMenuClick(int index)
    {
        onOptionChange(index);
        selectOption(index);
        await updateMenuState(false);
    }
    void onComboMenuMouseDown() => ignoreBlur = true;
    #endregion

    string getSearchString(string key)
    {
        Logger.LogInformation("getSearchString({key})", key);


        timer?.Dispose();

        timer = new System.Threading.Timer((state) =>
        {
            searchString = string.Empty;
            Logger.LogInformation("Timer tick.");
        }, null, TimeSpan.FromMilliseconds(5000), Timeout.InfiniteTimeSpan);

        if (key == "Backspace")
        {
            if (searchString.Length > 0)
                searchString = searchString[0..^1];
        }
        else if (key == "Clear")
        {
            searchString = string.Empty;
        }
        else if (key.Length == 1)
        {
            searchString = searchString + key[0];
        }

        Logger.LogInformation("SearchString '{searchString}'", searchString);

        return searchString;
    }
    
    async Task onComboType(string key)
    {
        await updateMenuState(true);

        var searchString1 = getSearchString(key);
        var searchIndex = getIndexByLetter(searchString1, activeIndex + 1);
        if (searchIndex >= 0)
        {
            Logger.LogInformation("Found index {index}.", searchIndex);

            onOptionChange(searchIndex);
        }
        else
        {
            timer?.Dispose();
            timer = null;

            searchString = string.Empty;
        }

        int getIndexByLetter(string ss, int index)
        {
            var orderedOptions = selectItems.Where(item => item.Key >= index)
                .Concat(selectItems.Where(item => item.Key < index));

            Logger.LogInformation("orderedOptions {o}", orderedOptions.Select(x => x.Value.Name));

            var firstMatch = orderedOptions.Where(x => x.Value.Name.StartsWith(ss, StringComparison.OrdinalIgnoreCase));

            return firstMatch.Any() ? firstMatch.First().Key : -1;
        }
    }
    public enum SelectAction
    {
        Close = 0,
        CloseSelect = 1,
        First = 2,
        Last = 3,
        Next = 4,
        Open = 5,
        PageDown = 6,
        PageUp = 7,
        Previous = 8,
        Select = 9,
        Type = 10,
    };
    [JSInvokable]
    public async Task onComboTypeJS(string key)
    {
        await onComboType(key);
        StateHasChanged();
    }
    [JSInvokable]
    public void onOptionChangeJS(SelectAction action)
    {
        Logger.LogInformation("onOptionChangeJS({action})", action);
        onOptionChange(getUpdatedIndex(activeIndex, selectItems.Count - 1, action));
        StateHasChanged();

        int getUpdatedIndex(int currentIndex, int maxIndex, SelectAction action)
        {
            const int pageSize = 10; // used for pageup/pagedown

            switch (action)
            {
                case SelectAction.First:
                    return 0;
                case SelectAction.Last:
                    return maxIndex;
                case SelectAction.Previous:
                    return Math.Max(0, currentIndex - 1);
                case SelectAction.Next:
                    return Math.Min(maxIndex, currentIndex + 1);
                case SelectAction.PageUp:
                    return Math.Max(0, currentIndex - pageSize);
                case SelectAction.PageDown:
                    return Math.Min(maxIndex, currentIndex + pageSize);
                default:
                    return currentIndex;
            }
        }
    }
    
    
    [JSInvokable]
    public void selectOptionJS()
    {
        selectOption(activeIndex); // not neccessary
        StateHasChanged();
    }
    
    
    [JSInvokable]
    public async Task updateMenuStateJS(bool toOpen)
    {
        await updateMenuState(toOpen);
        StateHasChanged();
    }
    

    protected override void OnInitialized()
    {
        //base.OnInitialized();
        id = Helpers.GetRandomHtmlId();
        comboInputId = $"{id}-combo";
        comboMenuId = $"{id}-listbox";
        objRef = DotNetObjectReference.Create(this);
    }

    

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        selectItems.Clear();
        for (int index = 0; index < Items.Length; index++)
        {
            selectItems.Add(index, new SelectItem(Items[index], itemId(index)));
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var result = await JS.InvokeAsync<bool>("menuButton.installOnComboKeyDown", comboInputId, objRef);
            if (!result)
                Logger.LogError("Failed to install keydown handler.");
        }
    }

    public void Dispose()
    {
        timer?.Dispose();
        if (objRef is not null)
        {
            objRef.Dispose();
        }
    }

    private class SelectItem
    {
        public string Name { get; private set; }
        public string Id { get; private set; }

        public SelectItem(string name, string id) => (Name, Id) = (name, id);
    }
}
